{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "8ed0faa5_1e0cb483",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1096528
      },
      "writtenOn": "2024-05-25T03:11:55Z",
      "side": 1,
      "message": "Hi @asmitapoddar@google.com @vdevmurari@google.com @arpitks@google.com! Please consider this change and let me know if you\u0027d like any alterations or have any objections.",
      "revId": "43da06f310c76bdb0e475730f54c4a92b4597e07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dce7019c_fd42135e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1096528
      },
      "writtenOn": "2024-05-30T18:02:39Z",
      "side": 1,
      "message": "Hi @asmitapoddar@google.com @vdevmurari@google.com @arpitks@google.com just a quick ping again for visibility. Thanks!",
      "parentUuid": "8ed0faa5_1e0cb483",
      "revId": "43da06f310c76bdb0e475730f54c4a92b4597e07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "73e53da4_6a370524",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1407716
      },
      "writtenOn": "2024-06-03T14:12:22Z",
      "side": 1,
      "message": "Hi @tophyr@gmail.com,\n\nThanks for the change! Can you please elaborate why this is needed?\n\nWe are actively trying to reduce the dependencies on global monitors for input, and would eventually like to remove this API altogether. There may be alternative APIs that might be better suited for your use case.",
      "revId": "43da06f310c76bdb0e475730f54c4a92b4597e07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f6649cdf_8cd62826",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1149384
      },
      "writtenOn": "2024-06-03T16:43:43Z",
      "side": 1,
      "message": "Right, I would expect apps with this permissions to launch a window with SPY flag instead. I don\u0027t think we should be building on top of this monitor stuff, and should ideally try to remove it.",
      "parentUuid": "73e53da4_6a370524",
      "revId": "43da06f310c76bdb0e475730f54c4a92b4597e07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a1fb9d23_2a1734ba",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1149384
      },
      "writtenOn": "2024-06-03T16:44:13Z",
      "side": 1,
      "message": "Reopening",
      "parentUuid": "f6649cdf_8cd62826",
      "revId": "43da06f310c76bdb0e475730f54c4a92b4597e07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a47e04c4_db855dbb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1096528
      },
      "writtenOn": "2024-06-04T00:54:57Z",
      "side": 1,
      "message": "@prabirmsp@google.com @svv@google.com I saw the spy window stuff but it seems focused on gesture monitors.\n\nThe use case here is a (appropriately-privileged) Service-based system that needs to monitor both KeyEvent and non-touch-based MotionEvent streams. Gesture monitors can\u0027t do that, unfortunately. Because it\u0027s a Service, it doesn\u0027t really have a Window either.\n\nI do see that nearly all of the references to `monitorInput()` have been eliminated - afaict all monitors in AOSP have been interested in pointer events. Do you have any suggestions on how to better accomplish monitoring of KeyEvents?",
      "parentUuid": "a1fb9d23_2a1734ba",
      "revId": "43da06f310c76bdb0e475730f54c4a92b4597e07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0357f4fc_096522c5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1096528
      },
      "writtenOn": "2024-06-04T00:54:57Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "dce7019c_fd42135e",
      "revId": "43da06f310c76bdb0e475730f54c4a92b4597e07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9e61460a_d47031c1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1149384
      },
      "writtenOn": "2024-06-04T08:17:27Z",
      "side": 1,
      "message": "Can you explain why the service needs to monitor keys? What is it doing with them? What kind of keys is it for? We don\u0027t have an API today for key pilfering. What happens if your service decides to handle the key, and at the same time, some focused window also decides to handle the key?",
      "parentUuid": "a47e04c4_db855dbb",
      "revId": "43da06f310c76bdb0e475730f54c4a92b4597e07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d023568f_8983da6e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1096528
      },
      "writtenOn": "2024-06-04T17:10:31Z",
      "side": 1,
      "message": "I don\u0027t want to \"pilfer\", or prevent the intended destination from receiving, the event. I just want to receive it in parallel, which is why the InputMonitor functionality seemed so perfect.\n\nThe specific use case right now is for gamepad and joystick events, which are delivered as a combination of KeyEvents and MotionEvents.",
      "parentUuid": "9e61460a_d47031c1",
      "revId": "43da06f310c76bdb0e475730f54c4a92b4597e07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a2e1a3c5_10dc673e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1149384
      },
      "writtenOn": "2024-06-04T17:14:08Z",
      "side": 1,
      "message": "What are you trying to do with the gamepad / joystick events if you don\u0027t want to pilfer or handle them?",
      "parentUuid": "d023568f_8983da6e",
      "revId": "43da06f310c76bdb0e475730f54c4a92b4597e07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6362d8e4_04457015",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1096528
      },
      "writtenOn": "2024-06-04T17:26:21Z",
      "side": 1,
      "message": "I do need to handle them, I just don\u0027t need to prevent the destination from receiving them. The gamepad state is effectively being copied and exposed via a secondary API, for compatibility reasons. Applications will use either this secondary API, *or* the traditional flinger input, for consuming gamepad input - not both.\n\nI considered intercepting the flung input inside the target application (via modifications to the device\u0027s NDK implementation) but decided that was a smelly approach; I don\u0027t want to modify the client\u0027s behavior nor do I want my service to receive input *from* the client.",
      "parentUuid": "a2e1a3c5_10dc673e",
      "revId": "43da06f310c76bdb0e475730f54c4a92b4597e07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f717c28_73f0eb42",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1149384
      },
      "writtenOn": "2024-06-04T17:38:08Z",
      "side": 1,
      "message": "If the app already has to be modified to use this \"secondary API\", then why not just fix the app to handle the events the way you want them to be handled?\n\nIt seems smelly to me to instead send two different streams of the same user input to the apps and let them choose - the two streams will race against each other.",
      "parentUuid": "6362d8e4_04457015",
      "revId": "43da06f310c76bdb0e475730f54c4a92b4597e07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b4d5d360_73e8661c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1096528
      },
      "writtenOn": "2024-06-04T17:48:12Z",
      "side": 1,
      "message": "Apps are built to use one mechanism or the other. I don\u0027t expect that any application would pay attention to both streams - that would be effectively like using both fread() and std::ifstream on the same file.\n\nThe apps that I\u0027m targeting support for aren\u0027t being *modified* to support the secondary API, they *already* use that API and I\u0027m trying to build the data path to support it. I just also don\u0027t want to prevent apps that *do* pay attention to flung input, so that I don\u0027t break standard Android apps.\n\nIOW, even if the gamepad data were only delivered to the target application via InputFlinger, and then some wrapper logic in libandroid.so performed the API translation, it would be the same effect: The data is available in both interfaces and the application is able to consume it from either. \n\nI don\u0027t want to do the libandroid.so wrapper approach for the aforementioned \"avoid modifying client behavior\" reason, as well as some future-looking requirements I have that will necessitate a shared service knowing the current gamepad state at all times regardless of window focus.",
      "parentUuid": "8f717c28_73f0eb42",
      "revId": "43da06f310c76bdb0e475730f54c4a92b4597e07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9baffffa_1f9a3c4b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1149384
      },
      "writtenOn": "2024-06-04T20:28:56Z",
      "side": 1,
      "message": "\u003e I don\u0027t expect that any application would pay attention to both streams\n\nAPIs should be designed such that it\u0027s impossible to do the incorrect behaviour. We can\u0027t rely on the developers to do the right thing. Any behaviour that the developer might start to rely on can become load-bearing, and eventually impossible to remove or even modify. We are now having trouble with \"injectInputEvent\" precisely for that reason.\n\n\u003e The data is available in both interfaces and the application is able to consume it from either.\nI don\u0027t know what this second interface is, but it doesn\u0027t sound like something that\u0027s supported by the core Android, and is likely not a design we would want.\n\nThe description of your use case is vague and I don\u0027t see the need for this capability to receive focused events outside of the focused application. If we can do stuff in the app process, then that approach should be preferred. It\u0027s better for security, reduces latency, and removes synchronization issues.\n\nI don\u0027t see a valid reason to proceed with this change, so it\u0027s a nack from me.",
      "parentUuid": "b4d5d360_73e8661c",
      "revId": "43da06f310c76bdb0e475730f54c4a92b4597e07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d44bdf13_57d90279",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1096528
      },
      "writtenOn": "2024-06-05T01:36:31Z",
      "side": 1,
      "message": "\u003e APIs should be designed such that it\u0027s impossible to do the incorrect behaviour.\n\n@svv@google.com I worry that we got a little side-tracked by the specific use case I\u0027m solving. That use case is completely downstream of AOSP; no upstreaming of its specifics are intended. \n\nI totally agree with the quoted statement, but the interface I\u0027m trying to provide an implementation for is unfortunately not something I have the power to change - it\u0027s an external interface to which I must conform, in order to support applications built for a particular framework. The specific product requirements I face are, effectively, \"offer gamepad data via both traditional InputFlinger *and* this other API\". Regardless of how I end up accessing the data, the client-side API surface is already decided. (And, again, none of *that* noise is aimed at ever being merged back into AOSP. I\u0027m implementing those pieces with parts that can stay fully-downstream.)\n\nSticking with the context of that use case, my options as I see them are threefold:\n1. Perform API translation from `InputEvent` to the secondary API in the Focused Application, via additions to `libandroid.so`\n2. Find a way to get InputFlinger to \"properly\" deliver `InputEvent` data to the Service handling the secondary API logic\n3. Open `/dev/event` in my \"secondary API Service\" and read gamepad events directly from the kernel (effectively duplicating `InputReader.cpp`)\n\n#1 is undesirable because it would still require divergence on my part from AOSP-provided code, and it feels architecturally-smelly because I would in effect be creating a cycle in the \"data flow\" graph: InputFlinger would send an `InputEvent` to FooApp, where `libandroid.so` would intercept it and duplicate it onward to SecondaryApiService, only for SecondaryApiService to then re-expose the information to FooApp.\n\n#3 is undesirable because it seems very duplicative and also would be fairly wasteful of CPU.\n\n#2 is what I settled on as the \"right\" way, and this specific changeset is really just about enabling that - specifically, giving AOSP the architectural capability to duplicate key and non-touch input to a process that isn\u0027t the currently-focused window. This ability *nearly* already exists, in what I\u0027d consider a pretty well-designed fashion: It\u0027s permission-protected, it\u0027s simple and concise, and it\u0027s very low-overhead. All it needs is the actual registration method to be exposed via RPC.\n\nIf you can think of a better way to accomplish this (or have a point that you think would convince me that #1 or #3 are actually the right path) I\u0027m pretty open to suggestions, but I guess my position right now is that I think Android having the architectural capability to multicast `InputEvent` data is a valuable one.",
      "parentUuid": "9baffffa_1f9a3c4b",
      "revId": "43da06f310c76bdb0e475730f54c4a92b4597e07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "83d0e642_365bda23",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1096528
      },
      "writtenOn": "2024-06-07T15:02:49Z",
      "side": 1,
      "message": "Hi @svv@google.com, hoping to get your thoughts on the above. Thanks!",
      "parentUuid": "d44bdf13_57d90279",
      "revId": "43da06f310c76bdb0e475730f54c4a92b4597e07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "00deae3e_6ec62200",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1096528
      },
      "writtenOn": "2024-09-11T07:34:45Z",
      "side": 1,
      "message": "Hi @svv@google.com, I\u0027m picking this back up after a paternity break over the summer. We still need _some_ sort of mechanism for a privileged service to monitor both KeyEvents and MotionEvents in parallel to the currently-focused application. What would be the best way, in your view, to accomplish this?",
      "parentUuid": "83d0e642_365bda23",
      "revId": "43da06f310c76bdb0e475730f54c4a92b4597e07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "36446d00_beb054a2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1149384
      },
      "writtenOn": "2024-09-12T05:29:29Z",
      "side": 1,
      "message": "The official mechanism today for monitoring pointer events is a spy window. We currently don\u0027t have a mechanism for monitoring focused events.\n\nThe only way today for a system component to do that would be probably to add some kind of \"KEY_SPY\" input config for a window, or maybe have it go through \"interceptKeyBeforeQueueing / dispatching\", and then have WM send this to the entity of interest (similar path is used for system UI today via a custom interface), although that wouldn\u0027t work today for joystick events, so it would still require modifications in some part of inputflinger.\n\nWe don\u0027t have a critical need for this today in Android (except for converting PointerLocation to also display keys on screen), so it\u0027s not been thoroughly thought about or designed.\n\nI also don\u0027t quite understand your setup, because you are saying that you have a focused window, but at the same time, want to have *another* window that can monitor focused events (but in the end, it seems like you want these events to go to the same place). If you are trying to translate stuff for some kind of compatibility for the focused window, you don\u0027t need a spy, and should do this directly in the process of that focused window. Any other approach would introduce latency and would be more error-prone, because the changes would not be isolated to the receiving process.\n\nSince it sounds like you are working on your own fork anyways, I don\u0027t think you really need our approval to modify your code. It\u0027s still not clear from the provided description what this \"external service\" is and what its requirements are, so we don\u0027t have full visibility of the problem. Therefore can\u0027t really recommend one solution over the other (and it\u0027s not even clear that this is the right problem to solve to begin with). For example, maybe something like raw access to HID is what you actually need, and prevent the system from handling these input devices altogether.\n\nUnfortunately with the provided information we can\u0027t really be of more help to you, sorry",
      "parentUuid": "00deae3e_6ec62200",
      "revId": "43da06f310c76bdb0e475730f54c4a92b4597e07",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}